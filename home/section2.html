<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lock In Section - APEX</title>
    <!-- Styrene A Trial Font -->
    <link rel="stylesheet" href="https://use.typekit.net/[YOUR_KIT_CODE].css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'styrene-a-trial', sans-serif;
            background: #f5f5f5;
        }

        .lock-in-container {
            display: grid;
            /* fixed column widths requested by the user */
            grid-template-columns: 775px 545px;
            gap: 2rem;
            padding: 3rem 4rem;
            max-width: 1400px;
            margin: 0 auto;
            /* keep container tall enough if needed */
            min-height: 100vh;
            align-items: start;
        }

        /* Left Section - Product Benefits */
        .lock-in-left {
            background: linear-gradient(135deg, #1565a0 0%, #2196f3 50%, #00bcd4 100%);
            border-radius: 24px;
            padding: 4rem 3rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* fixed height as requested */
            height: 735px;
            position: relative;
            overflow: hidden;
        }

        .lock-in-left::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }

        .lock-in-left > * {
            position: relative;
            z-index: 2;
        }

        .lock-in-title {
            font-size: 2.8rem;
            font-weight: 800;
            color: white;
            text-align: center;
            margin-bottom: 3rem;
            letter-spacing: -1px;
        }

        .product-diagram {
            position: relative;
            width: 350px;
            height: 350px;
            margin: 2rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .product-box {
            position: absolute;
            width: 200px;
            height: 240px;
            background: url('assets/');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            animation: popIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            z-index: 10;
            filter: drop-shadow(0 20px 40px rgba(0, 0, 0, 0.2));
        }

        @keyframes popIn {
            0% {
                opacity: 0;
                transform: scale(0.3) rotateZ(-10deg);
            }
            50% {
                transform: scale(1.05) rotateZ(5deg);
            }
            100% {
                opacity: 1;
                transform: scale(1) rotateZ(0deg);
            }
        }

        .benefit-label {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            opacity: 0;
        }

        .benefit-label.show {
            animation: slideInLabel 0.6s ease-out forwards;
        }

        @keyframes slideInLabel {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Benefit Label Positions */
        .benefit-label.top-left {
            top: 30px;
            left: -80px;
            animation-delay: 0.8s;
        }

        .benefit-label.top-right {
            top: 30px;
            right: -60px;
            animation-delay: 1s;
        }

        .benefit-label.middle-left {
            top: 50%;
            left: -90px;
            transform: translateY(-50%);
            animation-delay: 1.2s;
        }

        .benefit-label.middle-right {
            top: 50%;
            right: -80px;
            transform: translateY(-50%);
            animation-delay: 1.4s;
        }

        .benefit-label.bottom-left {
            bottom: 30px;
            left: -80px;
            animation-delay: 1.6s;
        }

        .benefit-label.bottom-right {
            bottom: 30px;
            right: -90px;
            animation-delay: 1.8s;
        }

        .benefit-label.top-middle-left {
            top: -40px;
            left: 20px;
            animation-delay: 0.9s;
        }

        .benefit-label.top-middle-right {
            top: -40px;
            right: 20px;
            animation-delay: 1.1s;
        }

        .label-dot {
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
        }

        .label-line {
            position: absolute;
            stroke: rgba(255, 255, 255, 0.6);
            stroke-width: 2;
            stroke-dasharray: 100;
            stroke-dashoffset: 100;
        }

        .label-line.show {
            animation: drawLine 0.8s ease-out forwards;
        }

        @keyframes drawLine {
            to {
                stroke-dashoffset: 0;
            }
        }

        .label-text {
            font-size: 0.9rem;
            font-weight: 600;
            color: white;
            padding: 0.6rem 1.2rem;
            border: 1.5px solid rgba(255, 255, 255, 0.6);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            white-space: nowrap;
            transition: all 0.3s ease;
        }

        .label-text:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: white;
        }

        .buy-button {
            margin-top: 3rem;
            background: white;
            color: #1565a0;
            border: none;
            padding: 0.9rem 2rem;
            font-size: 1rem;
            font-weight: 700;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .buy-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        /* Right Section - Graph */
        .lock-in-right {
            background: linear-gradient(135deg, #e0f7fa 0%, #b3e5fc 50%, #81d4fa 100%);
            border-radius: 24px;
            padding: 3rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            /* fixed height to match left column */
            height: 735px;
            position: relative;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .graph-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 1.5rem;
        }

        .graph-icon {
            width: 24px;
            height: 24px;
            background: #00acc1;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: white;
        }

        .graph-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #00acc1;
        }

        .graph-title {
            font-size: 2.5rem;
            font-weight: 800;
            color: #000;
            margin-bottom: 1rem;
            letter-spacing: -1px;
        }

        .graph-tags {
            display: flex;
            gap: 0.8rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .tag {
            font-size: 0.85rem;
            font-weight: 600;
            color: #00acc1;
            background: rgba(0, 172, 193, 0.1);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .tag::after {
            content: 'â†—';
            font-size: 0.8rem;
        }

        .graph-container {
            position: relative;
            width: 100%;
            height: 280px;
            background: white;
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .before-after-labels {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            top: 0;
            left: 0;
            padding: 1.5rem;
        }

        .before-label,
        .after-label {
            position: absolute;
            font-size: 0.9rem;
            font-weight: 600;
            color: #666;
        }

        .before-label {
            bottom: 40px;
            left: 20px;
            opacity: 0;
            animation: fadeIn 1.5s ease-out 0.5s forwards;
        }

        .after-label {
            top: 15px;
            right: 20px;
            opacity: 0;
            animation: fadeIn 1.5s ease-out 1s forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .lock-in-container {
                grid-template-columns: 1fr;
                padding: 2rem;
            }

            .lock-in-title {
                font-size: 2.2rem;
            }

            .graph-title {
                font-size: 2rem;
            }
        }

        @media (max-width: 768px) {
            .lock-in-container {
                padding: 1.5rem;
                gap: 1.5rem;
            }

            .lock-in-left,
            .lock-in-right {
                min-height: 400px;
            }

            .lock-in-title {
                font-size: 1.8rem;
            }

            .product-diagram {
                width: 250px;
                height: 250px;
            }

            .graph-title {
                font-size: 1.6rem;
            }

            .benefit-label {
                display: none;
            }
        }
    </style>
</head>
<body>

<div class="lock-in-container">
    <!-- Left Section -->
    <div class="lock-in-left">
        <h2 class="lock-in-title">Its Time To Lock In</h2>
        
        <div class="product-diagram">
            <svg class="diagram-lines" width="350" height="350" style="position: absolute;">
                <!-- Lines will be drawn by JavaScript -->
            </svg>
            <div class="product-box"></div>
            
            <!-- Benefit Labels -->
            <div class="benefit-label top-middle-left">
                <div class="label-dot"></div>
                <div class="label-text">Performance</div>
            </div>

            <div class="benefit-label top-middle-right">
                <div class="label-dot"></div>
                <div class="label-text">Precision</div>
            </div>

            <div class="benefit-label top-left">
                <div class="label-dot"></div>
                <div class="label-text">Reaction Time</div>
            </div>

            <div class="benefit-label middle-left">
                <div class="label-dot"></div>
                <div class="label-text">Speed</div>
            </div>

            <div class="benefit-label bottom-left">
                <div class="label-dot"></div>
                <div class="label-text">Vigilance</div>
            </div>

            <div class="benefit-label top-right">
                <div class="label-dot"></div>
                <div class="label-text">Concentration</div>
            </div>

            <div class="benefit-label middle-right">
                <div class="label-dot"></div>
                <div class="label-text">Endurance</div>
            </div>

            <div class="benefit-label bottom-right">
                <div class="label-dot"></div>
                <div class="label-text">Emotional Status</div>
            </div>
        </div>

        <button class="buy-button">ðŸ›’ Buy Now</button>
    </div>

    <!-- Right Section -->
    <div class="lock-in-right">
        <div class="graph-header">
            <div class="graph-icon">ðŸ“Š</div>
            <div class="graph-label">Graph</div>
        </div>

        <h2 class="graph-title">After Taking The<br>Gum</h2>

        <div class="graph-tags">
            <span class="tag">Increased Energy</span>
            <span class="tag">Focus</span>
            <span class="tag">Endurance</span>
        </div>

        <div class="graph-container">
            <canvas id="energyChart"></canvas>
            <div class="before-after-labels">
                <span class="before-label">Before</span>
                <span class="after-label">After</span>
            </div>
        </div>
    </div>
</div>

<script>
    // Animate benefit labels on page load
    window.addEventListener('load', () => {
        const labels = document.querySelectorAll('.benefit-label');
        setTimeout(() => {
            labels.forEach(label => {
                label.classList.add('show');
            });
            drawConnectionLines();
        }, 500);
    });

    // Draw animated connection lines
    function drawConnectionLines() {
        const svg = document.querySelector('.diagram-lines');
        const productBox = document.querySelector('.product-box');
        const rect = productBox.getBoundingClientRect();
        const diagram = document.querySelector('.product-diagram');
        const diagramRect = diagram.getBoundingClientRect();

        const boxCenterX = rect.left - diagramRect.left + rect.width / 2;
        const boxCenterY = rect.top - diagramRect.top + rect.height / 2;

        const labels = document.querySelectorAll('.benefit-label');

        labels.forEach((label, index) => {
            const labelRect = label.getBoundingClientRect();
            const labelX = labelRect.left - diagramRect.left + labelRect.width / 2;
            const labelY = labelRect.top - diagramRect.top + labelRect.height / 2;

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', boxCenterX);
            line.setAttribute('y1', boxCenterY);
            line.setAttribute('x2', labelX);
            line.setAttribute('y2', labelY);
            line.setAttribute('class', 'label-line');
            svg.appendChild(line);

            setTimeout(() => {
                line.classList.add('show');
            }, 800 + (index * 150));
        });
    }

    // Canvas Chart Animation
    function drawChart() {
        const canvas = document.getElementById('energyChart');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        const container = canvas.parentElement;
        canvas.width = container.clientWidth - 30;
        canvas.height = container.clientHeight - 30;

        const width = canvas.width;
        const height = canvas.height;
        const padding = 30;
        const chartWidth = width - padding * 2;
        const chartHeight = height - padding * 2;

        // Data points
        const dataPoints = [
            {x: 0, y: 30},
            {x: 20, y: 35},
            {x: 40, y: 50},
            {x: 60, y: 75},
            {x: 80, y: 95},
            {x: 100, y: 100},
            {x: 120, y: 95},
            {x: 140, y: 85},
            {x: 160, y: 70}
        ];

        // Normalize points
        const maxX = 160;
        const maxY = 110;

        const normalizedPoints = dataPoints.map(p => ({
            x: padding + (p.x / maxX) * chartWidth,
            y: height - padding - (p.y / maxY) * chartHeight
        }));

        // Draw animated curve
        const animationDuration = 2000;
        const startTime = Date.now();

        function animate() {
            const currentTime = Date.now() - startTime;
            const progress = Math.min(currentTime / animationDuration, 1);

            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            for (let i = 0; i <= 5; i++) {
                const y = padding + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            for (let i = 0; i <= 8; i++) {
                const x = padding + (chartWidth / 8) * i;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }

            // Draw filled area under curve
            ctx.fillStyle = 'rgba(0, 172, 193, 0.15)';
            ctx.beginPath();
            ctx.moveTo(normalizedPoints[0].x, height - padding);

            for (let i = 0; i < normalizedPoints.length; i++) {
                if (i / normalizedPoints.length <= progress) {
                    const nextProgress = (i + 1) / normalizedPoints.length;
                    if (nextProgress <= progress) {
                        ctx.lineTo(normalizedPoints[i].x, normalizedPoints[i].y);
                    } else {
                        const localProgress = (progress - (i / normalizedPoints.length)) / (1 / normalizedPoints.length);
                        const currentX = normalizedPoints[i].x + (normalizedPoints[i + 1].x - normalizedPoints[i].x) * localProgress;
                        const currentY = normalizedPoints[i].y + (normalizedPoints[i + 1].y - normalizedPoints[i].y) * localProgress;
                        ctx.lineTo(currentX, currentY);
                        break;
                    }
                }
            }

            ctx.lineTo(normalizedPoints[Math.min(Math.floor(progress * normalizedPoints.length), normalizedPoints.length - 1)].x, height - padding);
            ctx.closePath();
            ctx.fill();

            // Draw curve line
            ctx.strokeStyle = '#00acc1';
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            ctx.beginPath();

            for (let i = 0; i < normalizedPoints.length; i++) {
                if (i / normalizedPoints.length <= progress) {
                    const nextProgress = (i + 1) / normalizedPoints.length;
                    if (nextProgress <= progress) {
                        if (i === 0) {
                            ctx.moveTo(normalizedPoints[i].x, normalizedPoints[i].y);
                        } else {
                            ctx.lineTo(normalizedPoints[i].x, normalizedPoints[i].y);
                        }
                    } else {
                        const localProgress = (progress - (i / normalizedPoints.length)) / (1 / normalizedPoints.length);
                        const currentX = normalizedPoints[i].x + (normalizedPoints[i + 1].x - normalizedPoints[i].x) * localProgress;
                        const currentY = normalizedPoints[i].y + (normalizedPoints[i + 1].y - normalizedPoints[i].y) * localProgress;
                        if (i === 0) {
                            ctx.moveTo(currentX, currentY);
                        } else {
                            ctx.lineTo(currentX, currentY);
                        }
                        break;
                    }
                }
            }

            ctx.stroke();

            // Draw data points
            ctx.fillStyle = '#00acc1';
            for (let i = 0; i < normalizedPoints.length; i++) {
                if (i / normalizedPoints.length <= progress) {
                    ctx.beginPath();
                    ctx.arc(normalizedPoints[i].x, normalizedPoints[i].y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        }

        animate();
    }

    // Initialize chart when visible
    const observerOptions = {
        threshold: 0.3
    };

    const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                drawChart();
                observer.unobserve(entry.target);
            }
        });
    }, observerOptions);

    const graphContainer = document.querySelector('.graph-container');
    observer.observe(graphContainer);

    // Redraw on window resize
    window.addEventListener('resize', () => {
        if (document.querySelector('.graph-container').getBoundingClientRect().top < window.innerHeight) {
            drawChart();
        }
    });
</script>

</body>
</html>